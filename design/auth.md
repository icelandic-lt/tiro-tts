# Tiro TTS authorization

This document describes possible authorization and authentication implementation methods for Tiro TTS web service. The **two** methods described may both be implemented and users would be offered a choice of which one to use.

## 1. API key authorization and authentication
The user creates a project and asks for access to our TTS service. We grant access and provide a unique API key which may be used to interact with the service. The user makes TTS requests from his software's backend to our service, using the provided API key. Our service responds, as usual, with audio and metadata. We keep a usage record of projects in a database. Each project's name and user (owner) can be identified by the unique API key. We could, for instance, count TTS requests made using a certain API key to calculate accumulated usage.

### Pseudocode

#### **Project registration endpoint**
The project creation code might look somewhat like this:

```
@app.route("/v0/project", methods=["POST"])
def route_create_project():
    *some input validation*

    project: Project = db.projects._add_row(
        owner_id=req.body,uid,
        name=req.body.name,
        api_key=some_service.generate_api_key(),        # API key kept here OR in a separate table, hashed and salted.
        ...
    );

    return {status_code: 201, project}
```

#### **TTS endpoint**
The endpoint code might be modified along those lines:

```
@app.route("/v0/speech", methods=["POST"])
def route_synthesize_speech():
    api_key: str = body.headers.authorization

    if api_key not in db.api_keys:
        return status_code(403)

    *perform everything as usual*
    ...

    audio_len: int = audio_metadata["len_seconds"]

    # Each project belongs to some user which would then get charged for total elapsed time of requests made by his projects.
    db.tts_requests._add_row(
        project_id=db._query(
            f"""
            SELECT p.id
            FROM projects p
            WHERE p.api_key = \"{api_key}\";     # The keys might be kept in a separate table though, hashed and salted.
            """
        ).first(),
        date=time.now(),
        audio_duration=audio_len,
        ...
    )

    ...

    return response
```

#### **Usage duration calculation function**
This shows how we could calculate usage for some project.

```
def calculate_usage(project_id: int, date_range_lower: int, date_range_upper: int) -> int:
    return db._query(
            f"""
            SELECT SUM(t.audio_duration)
            FROM tts_requests t
            WHERE t.project_id = {str(project_id)}
            AND t.date >= \"{str(date_range_lower)}\"
            AND t.date <= \"{str(date_range_upper)}\";
            """
    ).first()
```

### Technical details (step-by-step)
The steps would be as follows:

1. The registered user creates his project and has a unique API key generated. We assume there is some web UI for this step.
    - Note: This step may also, to begin with, be such that we manually create the project ourselves and hand over the API key to the user.
2. His project is created in our backend. Rows are added to tables.
3. The user copies and pastes his API key and uses it in his software environment to enable TTS requests to our service.
4. The user makes a TTS request using his API key.
5. Our endpoint (```route_synthesize_speech```) responds and start to check if the key exists.
6. If the key exists, our service commences input proccessing as usual. Else, the endpoint responds immediately with a 403 Forbidden status code and no input processing takes place.
7. After the input has been processed and the output has been generated, but not returned (yet), we insert a row into the database which represents a log of this TTS request. There, in some ```tts_requests``` table for instance, we register this request. That includes which user it belongs to, which project, how long (in minutes or seconds) it was and perhaps something more.
8. The audio and metadata is returned to the user.

## 2. API key authorization with JWT authentication
The user creates a project and asks for access to our TTS service. We grant access and provide a unique API key which may be used to interact with the service. The developer makes requests for JWTs from his software's backend to our service, using the provided API key. Our service returns JWTs which the user's backend software can distribute to its clients (users). That way, the clients can interact with our service individually and make TTS requests. We can record the usage by keeping track of which generated JWTs belong to what project. If JWT X is generated for and distributed by some project Y which in turn is owned by some user Z, the usage of that key can be kept a record of in a database. We could effectively calculate accumulated usage by summing audio duration generated by TTS requests made using JWTs that belong to some project Y which is owned by some user Z.

### Pseudocode

#### **Project registration endpoint**
The project creation code might look somewhat like this:

```
@app.route("/v0/project", methods=["POST"])
def route_create_project():
    *some input validation*

    project: Project = db.projects._add_row(
        owner_id=req.body,uid,
        name=req.body.name,
        api_key=some_service.generate_api_key(),
        ...
    );

    return {status_code: 201, project}
```

#### **JWT endpoint**
The JWT endpoint code might look somewhat like this:

```
@app.route("/v0/token", methods=["GET"])
def route_get_jwt():
    api_key: str = body.headers.authorization

    # Only those in possession of an API key are allowed to get JWTs
    if api_key not in db.api_keys:
        return status_code(403)

    project: Project = Project.from_sql(
            db._query(
            f"""
            SELECT *
            FROM projects
            WHERE api_key = \"{api_key}\"
            """
        ).first()
    )

    new_jwt = jwt_package.generate_token(
        payload = {
            "project": project.name,
            "iat": time.now(),
            ...
        }
    )

    # This is done in order to keep track of requests made by each project.
    db.access_tokens._add_row(
        project_id=project.id,
        value=new_jwt,
        ...
    )

    return new_jwt
```

#### **TTS endpoint**
The TTS endpoint code might be modified along those lines:

```
@app.route("/v0/speech", methods=["POST"])
@jwt_required
def route_synthesize_speech():
    # jwt_required decorator ensures that we only let requests with valid JWTs through

    *perform everything as usual*
    ...

    jwt_val: str = req.body.authorization
    audio_len: int = audio_metadata["len_seconds"]

    # Each project belongs to some user which would then get charged for total elapsed time of requests made by his projects.
    db.tts_requests._add_row(
        project_id=db._query(
            f"""
            SELECT p.id 
            FROM projects p
                JOIN access_tokens a ON p.id = a.project_id
                WHERE a.value = \"{jwt_val}\";
            """
        ).first(),
        audio_duration=audio_len,
        date=time.now(),
        ...
    )

    ...

    return response
```

#### **Usage duration calculation function**
This shows how we could calculate usage for some project.

```
def calculate_usage(project_id: int, date_range_lower: int, date_range_upper: int) -> int:
    return db._query(
            f"""
            SELECT SUM(t.audio_duration)
            FROM tts_requests t
            WHERE t.project_id = {str(project_id)}
            AND t.date >= \"{str(date_range_lower)}\"
            AND t.date <= \"{str(date_range_upper)}\";
            """
    ).first()
```

### Technical details (step-by-step)
The steps would be as follows:

1. The registered user creates his project and has a unique API key generated. We assume there is some web UI for this step.
    - Note: This step may also, to begin with, be such that we manually create the project ourselves and hand over the API key to the user.
2. His project is created in our backend. Rows are added to tables.
3. The user copies and pastes his API key and uses it in his software environment to enable JWT requests to our service to get JWT tokens.
4. The user makes a JWT request using his API key.
5. Our endpoint (```route_get_jwt```) responds and start to check if the API key exists.
6. If the API key exists, a new JWT is generated. The new JWT is registered in the database along with the project ID (Which is found using the unique API key provided). That way, we know which project the JWT belongs to. Finally, the JWT is returned.
    - If the API key does not exist, the endpoint responds immediately with a 403 Forbidden status code and no JWT is created.
    - The user can now, using the provided JWT, send requests to the TTS endpoint (```route_synthesize_speech```).
    - This approach enables the user to make requests for JWTs in some backend environment and distribute to his clients which might, for instance, be web applications rendered in browsers that can store the JWT as cookies.
7. The user makes a TTS request with the returned JWT set in the request's ```authorization``` header.
8. If the JWT is valid, our service commences input proccessing as usual. Else, the endpoint responds immediately with a 403 Forbidden status code and no input processing takes place.
9. After the input has been processed and the output has been generated, but not returned (yet), we insert a row into the database which represents a log of this TTS request. There, in some ```tts_requests``` table for instance, we register this request. That includes which user it belongs to, which project, how long (in minutes or seconds) it was and perhaps something more.
    - We can figure out which project (and therefore, which user) the request belongs to by looking the JWT up in some ```access_tokens``` table. There, as is described in _Step 6_ above, the valid JWT has been registered along with which project it belongs to.
10. The audio and metadata is returned to the user.
